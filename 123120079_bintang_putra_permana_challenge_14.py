# -*- coding: utf-8 -*-
"""123120079_Bintang Putra Permana_Challenge 14

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/19ptpcWcS2Lu2zblIRiqz18fc1RdZn8E1
"""

import streamlit as st
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from scipy.ndimage import uniform_filter
from scipy.interpolate import griddata, NearestNDInterpolator
import io

# Konfigurasi Halaman
st.set_page_config(page_title="Analisis Magnetik 2D", layout="wide")

# --- JUDUL & INTRO ---
st.title("ðŸ—ºï¸ Pengolahan Data Magnetik 2D")
st.markdown("""
Aplikasi ini melakukan pemisahan anomali **Regional** dan **Residual**.
Mendukung proses **Gridding** dari data acak (scatter) menjadi data grid teratur.
""")

# --- FUNGSI GENERATOR DATA (Untuk Dummy) ---
def get_dummy_dataframe(grid_size=50):
    x = np.linspace(0, 1000, grid_size)
    y = np.linspace(0, 1000, grid_size)
    X, Y = np.meshgrid(x, y)

    # Buat anomali
    regional = 0.05 * X + 0.02 * Y + 45000
    r = np.sqrt((X - 500)**2 + (Y - 500)**2 + 50**2)
    residual = 5000 * (50 / r)**3
    noise = np.random.normal(0, 1, (grid_size, grid_size))
    total = regional + residual + noise

    # Flatten & Random Sampling untuk simulasi data lapangan acak
    df = pd.DataFrame({
        'x': X.flatten(),
        'y': Y.flatten(),
        't_obs': total.flatten()
    })

    # Ambil sampel acak (misal 80% data) agar terlihat seperti data scatter
    return df.sample(frac=0.8).reset_index(drop=True)

# --- FUNGSI PENGOLAHAN UTAMA ---
def polyfit2d(x, y, z, order=1):
    x = x.flatten()
    y = y.flatten()
    z = z.flatten()

    # Filter NaN sebelum fitting
    mask = ~np.isnan(z)
    x, y, z = x[mask], y[mask], z[mask]

    if order == 1:
        A = np.c_[np.ones(x.shape), x, y]
    elif order == 2:
        A = np.c_[np.ones(x.shape), x, y, x**2, x*y, y**2]

    C, _, _, _ = np.linalg.lstsq(A, z, rcond=None)

    # Return fungsi lambda untuk menghitung nilai prediksi di sembarang titik
    if order == 1:
        return lambda xi, yi: C[0] + C[1]*xi + C[2]*yi
    elif order == 2:
        return lambda xi, yi: C[0] + C[1]*xi + C[2]*yi + C[3]*xi**2 + C[4]*xi*yi + C[5]*yi**2

# --- SIDEBAR: UPLOAD DATA ---
st.sidebar.header("ðŸ“‚ Input Data")
uploaded_file = st.sidebar.file_uploader("Upload file CSV", type=['csv'])

if uploaded_file is not None:
    df_input = pd.read_csv(uploaded_file)
    st.sidebar.success(f"Data berhasil diupload! ({len(df_input)} baris)")
else:
    st.sidebar.info("Menggunakan data dummy (contoh)")
    df_input = get_dummy_dataframe(50)

# --- KONFIGURASI VISUALISASI DI SIDEBAR ---
st.sidebar.header("ðŸŽ¨ Pengaturan Visualisasi")

# 1. Pilihan Colormap
colormaps = ['jet', 'viridis', 'plasma', 'coolwarm', 'seismic', 'rainbow', 'terrain', 'Spectral']
selected_cmap = st.sidebar.selectbox(
    "Pilih Colormap",
    colormaps,
    index=0,
    help="Pilih warna untuk kontur plot"
)

# 2. Mode Scaling
scale_mode = st.sidebar.radio(
    "Mode Scaling",
    ["Auto", "Manual"],
    index=0,
    help="Auto: nilai min/max otomatis. Manual: tentukan sendiri"
)

# 3. Slider untuk manual scaling (hanya tampil jika manual dipilih)
vmin_val, vmax_val = None, None
if scale_mode == "Manual":
    # Hitung range data untuk set default slider
    data_min = float(df_input['t_obs'].min())
    data_max = float(df_input['t_obs'].max())
    data_range = data_max - data_min

    col1, col2 = st.sidebar.columns(2)
    with col1:
        vmin_val = st.sidebar.slider(
            "Nilai Minimum (vmin)",
            min_value=float(data_min - data_range),
            max_value=float(data_max + data_range),
            value=float(data_min),
            step=10.0
        )
    with col2:
        vmax_val = st.sidebar.slider(
            "Nilai Maksimum (vmax)",
            min_value=float(data_min - data_range),
            max_value=float(data_max + data_range),
            value=float(data_max),
            step=10.0
        )

# 4. Opsi Tambahan
st.sidebar.header("âš™ï¸ Opsi Tambahan")
reverse_axis = st.sidebar.checkbox("Balik Sumbu Y", value=False)
save_plots = st.sidebar.checkbox("Aktifkan Penyimpanan Plot", value=True)

# --- PROSES GRIDDING ---
if df_input is not None:
    st.sidebar.markdown("---")
    st.sidebar.subheader("ðŸ”§ Parameter Gridding")

    # 1. Tentukan Batas Area
    x_min, x_max = df_input['x'].min(), df_input['x'].max()
    y_min, y_max = df_input['y'].min(), df_input['y'].max()

    st.sidebar.text(f"Range X: {x_min:.1f} - {x_max:.1f} m")
    st.sidebar.text(f"Range Y: {y_min:.1f} - {y_max:.1f} m")

    # 2. Input Ukuran Sel
    default_cell = (x_max - x_min) / 50
    cell_size = st.sidebar.number_input(
        "Ukuran Sel (Meter)",
        min_value=1.0,
        max_value=(x_max - x_min) / 5,
        value=float(default_cell),
        step=5.0,
        help="Semakin kecil nilai ini, resolusi peta semakin tinggi"
    )

    # 3. Metode Interpolasi
    interp_method = st.sidebar.selectbox(
        "Metode Interpolasi",
        ["linear", "cubic", "nearest"],
        index=0,
        help="'linear' standard, 'cubic' lebih halus, 'nearest' kotak-kotak"
    )

    # 4. Eksekusi Gridding
    xi = np.arange(x_min, x_max + cell_size, cell_size)
    yi = np.arange(y_min, y_max + cell_size, cell_size)
    X, Y = np.meshgrid(xi, yi)

    with st.spinner("Melakukan interpolasi data..."):
        T_obs = griddata(
            (df_input['x'], df_input['y']),
            df_input['t_obs'],
            (X, Y),
            method=interp_method
        )

    grid_shape = T_obs.shape
    st.sidebar.success(f"Grid Terbentuk: {grid_shape[1]}x{grid_shape[0]} node.")

    # --- VISUALISASI HASIL GRIDDING ---
    st.subheader("1. Visualisasi Data")
    tab1, tab2 = st.tabs(["ðŸ“Š Peta Kontur (Gridded)", "ðŸ“ Sebaran Titik Data (Scatter)"])

    with tab1:
        fig1, ax1 = plt.subplots(figsize=(10, 6))

        # Atur kontur berdasarkan mode scaling
        if scale_mode == "Manual" and vmin_val is not None and vmax_val is not None:
            c1 = ax1.contourf(X, Y, T_obs, levels=25, cmap=selected_cmap,
                             vmin=vmin_val, vmax=vmax_val)
        else:
            c1 = ax1.contourf(X, Y, T_obs, levels=25, cmap=selected_cmap)

        # Plot titik data asli
        ax1.scatter(df_input['x'], df_input['y'], c='k', s=5, alpha=0.2, label='Titik Pengukuran')

        # Konfigurasi plot
        if reverse_axis:
            ax1.invert_yaxis()

        ax1.set_title(f"Total Magnetic Intensity (Grid Spacing: {cell_size:.1f} m)")
        ax1.set_xlabel("Easting (X)")
        ax1.set_ylabel("Northing (Y)")
        ax1.legend(loc='upper right')
        ax1.set_aspect('equal')
        fig1.colorbar(c1, ax=ax1, label='nT')

        st.pyplot(fig1)

        # Tombol download plot
        if save_plots:
            buf = io.BytesIO()
            fig1.savefig(buf, format='png', dpi=300, bbox_inches='tight')
            st.download_button(
                label="ðŸ’¾ Download Plot Kontur",
                data=buf,
                file_name="peta_kontur_magnetik.png",
                mime="image/png"
            )

    with tab2:
        fig_scatter, ax_s = plt.subplots(figsize=(8, 6))
        sc = ax_s.scatter(df_input['x'], df_input['y'], c=df_input['t_obs'],
                         cmap=selected_cmap, s=10)

        if reverse_axis:
            ax_s.invert_yaxis()

        ax_s.set_title("Posisi Titik Pengukuran Asli")
        fig_scatter.colorbar(sc, ax=ax_s, label='nT')
        st.pyplot(fig_scatter)

        # Tombol download plot
        if save_plots:
            buf = io.BytesIO()
            fig_scatter.savefig(buf, format='png', dpi=300, bbox_inches='tight')
            st.download_button(
                label="ðŸ’¾ Download Plot Scatter",
                data=buf,
                file_name="scatter_magnetik.png",
                mime="image/png"
            )

    st.divider()

    # --- PENGOLAHAN (REGIONAL - RESIDUAL) ---
    st.subheader("2. Pemisahan Regional-Residual")

    # Handle NaN values
    mask_nan = np.isnan(T_obs)
    if np.any(mask_nan):
        mask_valid = ~mask_nan
        xx_valid, yy_valid = X[mask_valid], Y[mask_valid]
        zz_valid = T_obs[mask_valid]
        interp_nn = NearestNDInterpolator(list(zip(xx_valid, yy_valid)), zz_valid)
        T_filled = interp_nn(X, Y)
    else:
        T_filled = T_obs

    # Pilih metode pemisahan
    method = st.selectbox("Metode Pemisahan:", ["2D Moving Average", "Trend Surface Analysis"])
    Calculated_Regional = np.zeros_like(T_obs)

    if method == "2D Moving Average":
        window_pts = st.slider("Lebar Window (Grid Points)", 3, 200, 9, step=2)
        st.caption(f"Lebar fisik window â‰ˆ {window_pts * cell_size:.1f} meter")
        Calculated_Regional = uniform_filter(T_filled, size=window_pts, mode='nearest')
    elif method == "Trend Surface Analysis":
        poly_order = st.radio("Orde:", [1, 2], horizontal=True)
        poly_func = polyfit2d(X, Y, T_obs, order=poly_order)
        Calculated_Regional = poly_func(X, Y)

    Calculated_Residual = T_obs - Calculated_Regional

    # --- TAMPILAN HASIL REGIONAL-RESIDUAL ---
    col_reg, col_res = st.columns(2)

    with col_reg:
        st.markdown("#### ðŸ—ºï¸ Regional (Trend)")
        fig2, ax2 = plt.subplots(figsize=(6, 5))

        if scale_mode == "Manual" and vmin_val is not None and vmax_val is not None:
            c2 = ax2.contourf(X, Y, Calculated_Regional, levels=20,
                             cmap=selected_cmap, vmin=vmin_val, vmax=vmax_val)
        else:
            c2 = ax2.contourf(X, Y, Calculated_Regional, levels=20, cmap=selected_cmap)

        fig2.colorbar(c2, ax=ax2, label='nT')
        st.pyplot(fig2)

        # Tombol download plot
        if save_plots:
            buf = io.BytesIO()
            fig2.savefig(buf, format='png', dpi=300, bbox_inches='tight')
            st.download_button(
                label="ðŸ’¾ Download Plot Regional",
                data=buf,
                file_name="regional_magnetik.png",
                mime="image/png"
            )

    with col_res:
        st.markdown("#### ðŸŽ¯ Residual (Anomali Target)")
        fig3, ax3 = plt.subplots(figsize=(6, 5))

        # Hitung limit warna residual (abaikan NaN)
        valid_res = Calculated_Residual[~np.isnan(Calculated_Residual)]

        if scale_mode == "Manual" and vmin_val is not None and vmax_val is not None:
            # Untuk residual, gunakan range simetris jika manual
            max_abs = max(abs(vmin_val), abs(vmax_val))
            c3 = ax3.contourf(X, Y, Calculated_Residual, levels=20,
                             cmap=selected_cmap, vmin=-max_abs, vmax=max_abs)
        else:
            if len(valid_res) > 0:
                limit = np.percentile(np.abs(valid_res), 98)
            else:
                limit = 100
            c3 = ax3.contourf(X, Y, Calculated_Residual, levels=20,
                             cmap=selected_cmap, vmin=-limit, vmax=limit)

        fig3.colorbar(c3, ax=ax3, label='nT')
        st.pyplot(fig3)

        # Tombol download plot
        if save_plots:
            buf = io.BytesIO()
            fig3.savefig(buf, format='png', dpi=300, bbox_inches='tight')
            st.download_button(
                label="ðŸ’¾ Download Plot Residual",
                data=buf,
                file_name="residual_magnetik.png",
                mime="image/png"
            )

# --- FOOTER ---
st.divider()
st.info("""
**Challenge Selesai!** Fitur yang telah diimplementasikan:
1. âœ… Pilihan colormap yang dapat disesuaikan
2. âœ… Kontrol manual vmin dan vmax dengan slider
3. âœ… Opsi Auto Scale dan Manual Scale
4. âœ… Opsi pembalik sumbu Y
5. âœ… Opsi penyimpanan plot sebagai gambar PNG
""")